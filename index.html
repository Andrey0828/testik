<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по СиАОД - Самопроверка</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 15px;
        }
        .question {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            transition: all 0.3s;
        }
        .question.correct {
            border-left-color: #28a745;
            background-color: #e8f5e8;
        }
        .question.incorrect {
            border-left-color: #dc3545;
            background-color: #fde8e8;
        }
        .question-number {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .question-text {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        .options {
            margin-left: 20px;
        }
        .option {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        }
        .option:hover {
            background-color: #e9ecef;
        }
        .option input {
            margin-right: 10px;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
            display: none;
        }
        .correct-result {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .incorrect-result {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        #results {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            background-color: #e8f4fc;
            display: none;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            font-size: 18px;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        #score {
            color: #e74c3c;
        }
        #correct-count {
            color: #27ae60;
        }
        #incorrect-count {
            color: #e74c3c;
        }
        .explanation {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            font-size: 0.9em;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.3s;
        }
        .progress-text {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Тест по СиАОД - Самопроверка</h1>
        
        <div class="progress-text">Прогресс: <span id="progress-value">0</span>%</div>
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        
        <div id="questions-container">
            <!-- Вопросы будут добавлены динамически -->
        </div>
        
        <div class="controls">
            <button id="show-results-btn">Показать результаты</button>
            <button id="reset-btn">Сбросить все ответы</button>
        </div>
        
        <div id="results">
            <h2>Результаты теста</h2>
            <div class="stats">
                <div class="stat">
                    <div>Правильных ответов:</div>
                    <div id="correct-count" class="stat-value">0</div>
                </div>
                <div class="stat">
                    <div>Неправильных ответов:</div>
                    <div id="incorrect-count" class="stat-value">0</div>
                </div>
                <div class="stat">
                    <div>Общий балл:</div>
                    <div id="score" class="stat-value">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Вопросы и варианты ответов
        const questions = [
            {
                number: 1,
                text: "Какая структура данных относятся к категории линейных списков?",
                options: [
                    "Дек",
                    "Бинарное дерево",
                    "Граф",
                    "Хеш-таблица"
                ],
                correct: 0,
                explanation: "Дек (double-ended queue) - это линейная структура данных, позволяющая добавлять и удалять элементы с обоих концов."
            },
            {
                number: 2,
                text: "Какие нотации можно использовать для асимптотической оценки сложности алгоритма в лучшем случае?",
                options: [
                    "Только О-большое",
                    "Только Ω-большое",
                    "Ω-большое и Θ-тета",
                    "Только Θ-тета"
                ],
                correct: 2,
                explanation: "Ω-нотация используется для оценки нижней границы (лучший случай), Θ-нотация - для точной оценки, когда верхняя и нижняя границы совпадают."
            },
            {
                number: 3,
                text: "Имеется узел АВЛ-дерева, для которого |hl-hr|=0, где hl, hr высота левого и правого поддерева соответственно. В левое поддерево вставляется новый ключ, после этого:",
                options: [
                    "Требуется перестройка дерева",
                    "Не требуется перестройка дерева",
                    "Требуется только один поворот",
                    "Требуется два поворота"
                ],
                correct: 1,
                explanation: "После вставки в левое поддерево разница высот станет 1, что допустимо для АВЛ-дерева (допустимые значения: -1, 0, 1)."
            },
            {
                number: 4,
                text: "Что обеспечивает метод пробирования \"двойное хеширование\" при вставке элемента в хеш-таблицу, разрешающей коллизии по методу открытого адреса?",
                options: [
                    "Вычисление смещения, не зависящее от значения ключа",
                    "Минимизацию кластеризации",
                    "Максимальное заполнение таблицы",
                    "Вычисление смещения, зависящее от значения ключа"
                ],
                correct: 3,
                explanation: "Двойное хеширование использует вторую хеш-функцию для вычисления шага смещения при коллизиях, что уменьшает кластеризацию."
            },
            {
                number: 5,
                text: "Какие нотации можно использовать для асимптотической оценки сложности алгоритма в худшем случае?",
                options: [
                    "Только О-большое",
                    "Только Ω-большое",
                    "О-большое и Θ-тета",
                    "Только Θ-тета"
                ],
                correct: 2,
                explanation: "О-нотация используется для оценки верхней границы (худший случай), Θ-нотация - для точной оценки, когда верхняя и нижняя границы совпадают."
            },
            {
                number: 6,
                text: "Что необходимо делать с большим объемом информации, связанной с каждым ключом:",
                options: [
                    "Хранить ее в хеш-таблице",
                    "Не хранить ее в хеш-таблице",
                    "Разделять на несколько таблиц",
                    "Сжимать перед хранением"
                ],
                correct: 1,
                explanation: "В хеш-таблице следует хранить только ключи и ссылки на данные, а сами данные размещать отдельно для эффективности работы таблицы."
            },
            {
                number: 7,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска по бинарному дереву в худшем случае (несбалансированное бинарное дерево)?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 2,
                explanation: "В несбалансированном бинарном дереве поиск может выродиться в линейный, поэтому сложность в худшем случае O(n)."
            },
            {
                number: 8,
                text: "Бинарное дерево - это:",
                options: [
                    "дерево, у которого каждый узел может содержать до двух дочерних узлов",
                    "дерево, у которого все узлы имеют по два потомка",
                    "дерево, у которого высота левого и правого поддеревьев отличается не более чем на 1",
                    "дерево, содержащее только два узла"
                ],
                correct: 0,
                explanation: "Бинарное дерево определяется как дерево, в котором каждый узел имеет не более двух потомков."
            },
            {
                number: 9,
                text: "Отличительная особенность алгоритма Бойера-Мура-Хорспула:",
                options: [
                    "Сравнение символов производится с начала образца",
                    "Использует префикс-функцию",
                    "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с эвристикой стоп-символов",
                    "Основан на хеш-функции"
                ],
                correct: 2,
                explanation: "Алгоритм Бойера-Мура-Хорспула использует эвристику стоп-символов для определения величины сдвига при несовпадении."
            },
            {
                number: 10,
                text: "Какое из условий проверяется при определении сбалансированности красно-черного дерева?",
                options: [
                    "Все узлы должны быть красного цвета",
                    "Любой путь от корня дерева к листу содержит одно и то же число черных узлов",
                    "Высота левого и правого поддеревьев должна быть одинаковой",
                    "Корень дерева должен быть черным"
                ],
                correct: 1,
                explanation: "В красно-черном дереве все пути от корня к листьям должны содержать одинаковое количество черных узлов (свойство черной высоты)."
            },
            {
                number: 11,
                text: "Росту первичного кластера в хеш-таблице с открытым адресом способствует:",
                options: [
                    "Для большого количества ключей хеш-функция сформировала один и тот же индекс",
                    "Смещение и размер таблицы имеют общие множители",
                    "Использование двойного хеширования",
                    "Оба первых варианта верны"
                ],
                correct: 3,
                explanation: "Первичный кластер возникает, когда хеш-функция генерирует одинаковые индексы для разных ключей, а также когда шаг смещения и размер таблицы имеют общие множители."
            },
            {
                number: 12,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска хешированием в худшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 2,
                explanation: "В худшем случае все ключи могут попасть в одну ячейку, и поиск будет иметь линейную сложность O(n)."
            },
            {
                number: 13,
                text: "Основное требование, предъявляемое к массиву для возможности выполнения двоичного поиска:",
                options: [
                    "Массив должен быть отсортирован",
                    "Массив должен быть однородным",
                    "Массив должен быть небольшим",
                    "Массив должен содержать только числа"
                ],
                correct: 0,
                explanation: "Двоичный поиск требует, чтобы массив был отсортирован, так как он использует свойство упорядоченности для деления области поиска пополам."
            },
            {
                number: 14,
                text: "Какие отношения между элементами поддерживает структура данных бинарное дерево?",
                options: [
                    "Линейные",
                    "Иерархические",
                    "Сетевые",
                    "Реляционные"
                ],
                correct: 1,
                explanation: "Бинарное дерево представляет собой иерархическую структуру, где каждый элемент (узел) имеет родителя и дочерние элементы."
            },
            {
                number: 15,
                text: "Какие существуют случаи в анализе алгоритма:",
                options: [
                    "Только наилучший и наихудший",
                    "Только средний",
                    "Наилучший, средний и наихудший",
                    "Только наихудший"
                ],
                correct: 2,
                explanation: "При анализе алгоритмов рассматривают три случая: наилучший (best case), средний (average case) и наихудший (worst case)."
            },
            {
                number: 16,
                text: "Имеется некоторая линейная структура данных, в которую заносятся упорядоченные по возрастанию символы. Считывание данных из этой структуры даёт результат: F, E, D, C, B, A. Чем может быть эта структура данных?",
                options: [
                    "Очередь",
                    "Дек",
                    "Стек",
                    "Дек или стек"
                ],
                correct: 3,
                explanation: "Если символы заносятся в порядке A,B,C,D,E,F, то при считывании F,E,D,C,B,A это может быть стек (LIFO) или дек с определенной дисциплиной доступа."
            },
            {
                number: 17,
                text: "В основе алгоритма Рабина-Карпа используется:",
                options: [
                    "Префикс-функция",
                    "Хеш-функция",
                    "Эвристика стоп-символов",
                    "Дерево поиска"
                ],
                correct: 1,
                explanation: "Алгоритм Рабина-Карпа использует хеш-функцию для быстрого сравнения подстрок с образцом."
            },
            {
                number: 18,
                text: "С какой вычислительной сложностью выполняются операции поиска, удаления и вставки в хеш-таблицах в лучшем случае?",
                options: [
                    "O(1)",
                    "O(log n)",
                    "O(n)",
                    "O(n²)"
                ],
                correct: 0,
                explanation: "В идеальном случае, когда нет коллизий, операции с хеш-таблицей выполняются за постоянное время O(1)."
            },
            {
                number: 19,
                text: "Какая операция считается недопустимой для линейного односвязного списка:",
                options: [
                    "Вставка нового элемента перед заданным элементом",
                    "Удаление заданного элемента",
                    "Поиск элемента",
                    "Вставка нового элемента после заданного элемента"
                ],
                correct: 0,
                explanation: "В односвязном списке невозможно эффективно вставить элемент перед заданным, так как нет ссылки на предыдущий элемент."
            },
            {
                number: 20,
                text: "Каков главный недостаток хеш-таблиц?",
                options: [
                    "Фиксированный размер, при неизвестном окончательном числе элементов",
                    "Сложность реализации",
                    "Невозможность удаления элементов",
                    "Медленный поиск"
                ],
                correct: 0,
                explanation: "Основной недостаток хеш-таблиц - фиксированный размер, который может привести к необходимости рехеширования при добавлении большого количества элементов."
            },
            {
                number: 21,
                text: "Имеется идеально сбалансированное двоичное дерево (не являющееся деревом поиска), содержащее целые числа. Симметричный просмотр дерева (слева-направо, in-oder обход) даёт следующий результат: 2, 4, 6, 8, 10, 12, 14. Какой узел является корнем дерева?",
                options: [
                    "4",
                    "6",
                    "8",
                    "10"
                ],
                correct: 2,
                explanation: "При симметричном обходе (in-order) корень находится посередине отсортированной последовательности. В данном случае это 8."
            },
            {
                number: 22,
                text: "В какой последовательности располагаются вершины дерева при прямом обходе (preorder):",
                options: [
                    "1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15",
                    "8, 9, 4, 10, 11, 5, 2, 12, 13, 6, 14, 15, 7, 3, 1",
                    "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15",
                    "8, 4, 9, 2, 10, 5, 11, 1, 12, 6, 13, 3, 14, 7, 15"
                ],
                correct: 0,
                explanation: "При прямом обходе (preorder) сначала посещается корень, затем рекурсивно обходится левое поддерево, затем правое поддерево."
            },
            {
                number: 23,
                text: "Показатели эффективности алгоритмов (или программ) включают:",
                options: [
                    "Только количество выполняемых операций",
                    "Только объем требуемой памяти",
                    "Количество выполняемых операций и объем требуемой памяти",
                    "Сложность реализации"
                ],
                correct: 2,
                explanation: "Основные показатели эффективности алгоритмов - временная сложность (количество операций) и пространственная сложность (объем памяти)."
            },
            {
                number: 24,
                text: "Какая структура данных используется для хранения элементов данных в хеш-таблице, при реализации разрешения коллизий по методу цепочек (цепного хеширования)?",
                options: [
                    "Массив",
                    "Однонаправленный список",
                    "Дерево",
                    "Очередь"
                ],
                correct: 1,
                explanation: "При цепочечном методе разрешения коллизий элементы с одинаковым хеш-кодом хранятся в виде однонаправленного списка."
            },
            {
                number: 25,
                text: "Идея алгоритма интерполяционного поиска основана на:",
                options: [
                    "Делении области поиска пополам",
                    "Выборе новой области поиска по расстоянию между ключом и текущим значением элемента",
                    "Использовании хеш-функции",
                    "Построении дерева поиска"
                ],
                correct: 1,
                explanation: "Интерполяционный поиск оценивает позицию искомого элемента на основе значения ключа и значений элементов на границах области поиска."
            },
            {
                number: 26,
                text: "Что означает утверждение, что алгоритм X асимптотически более эффективен, чем алгоритм Y?",
                options: [
                    "X всегда быстрее Y",
                    "X будет лучшим выбором для любых входных данных, начиная с некоторого граничного значения",
                    "X проще реализовать",
                    "X использует меньше памяти"
                ],
                correct: 1,
                explanation: "Асимптотическая эффективность означает, что при достаточно больших объемах входных данных алгоритм X будет работать быстрее алгоритма Y."
            },
            {
                number: 27,
                text: "Что будет выведено при прямом обходе дерева?",
                options: [
                    "a b d e c f",
                    "d b e a f c",
                    "d e b f c a",
                    "a b c d e f"
                ],
                correct: 0,
                explanation: "При прямом обходе (preorder) сначала посещается корень (a), затем левое поддерево (b, d, e), затем правое поддерево (c, f)."
            },
            {
                number: 28,
                text: "Укажите асимптотическую сложность операции удаления элемента в позиции i из массива размером n:",
                options: [
                    "O(1)",
                    "O(log n)",
                    "O(n)",
                    "O(n²)"
                ],
                correct: 2,
                explanation: "При удалении элемента из массива необходимо сдвинуть все последующие элементы, что в худшем случае требует O(n) операций."
            },
            {
                number: 29,
                text: "Высота (глубина) бинарного дерева поиска из N узлов в наилучшем случае определяется по формуле:",
                options: [
                    "h=n",
                    "h=log₂(n+1)",
                    "h=log₂(n+1)-1",
                    "h=log₂(n+1) или h=log₂(n+1)-1"
                ],
                correct: 3,
                explanation: "В наилучшем случае (сбалансированное дерево) высота равна log₂(n+1) или log₂(n+1)-1 в зависимости от точного определения высоты."
            },
            {
                number: 30,
                text: "В основе алгоритма Бойера-Мура-Хорспула используется:",
                options: [
                    "Префикс-функция",
                    "Хеш-функция",
                    "Эвристика стоп-символов",
                    "Дерево поиска"
                ],
                correct: 2,
                explanation: "Алгоритм Бойера-Мура-Хорспула использует эвристику стоп-символов (плохих символов) для определения величины сдвига."
            },
            {
                number: 31,
                text: "Для структуры данных стек справедливо:",
                options: [
                    "Линейный список с одной вершиной",
                    "Линейный список с двумя вершинами",
                    "Древовидная структура",
                    "Сетевая структура"
                ],
                correct: 0,
                explanation: "Стек - это линейная структура данных с одной точкой доступа (вершиной), работающая по принципу LIFO (последним пришел - первым ушел)."
            },
            {
                number: 32,
                text: "Какая проблема может возникнуть в хеш-таблице с открытым адресом, после удаления ключа из первичного кластера ключей, хешированных с одним индексом?",
                options: [
                    "Увеличение размера таблицы",
                    "Невозможность найти ключ в первичном кластере",
                    "Уменьшение производительности поиска",
                    "Автоматическое рехеширование"
                ],
                correct: 1,
                explanation: "При удалении элемента из кластера может нарушиться цепочка поиска, что сделает невозможным нахождение других элементов этого кластера."
            },
            {
                number: 33,
                text: "Какие поля должны содержать записи хеш-таблицы при использовании метода цепочек (цепного хеширования)?",
                options: [
                    "Только ключ",
                    "Ключ и значение",
                    "Указатель на начало списка элементов с одним и тем же значением хеш-функции",
                    "Ключ, значение и хеш-код"
                ],
                correct: 2,
                explanation: "При цепочечном методе каждая ячейка таблицы содержит указатель на начало списка элементов с одинаковым хеш-кодом."
            },
            {
                number: 34,
                text: "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=О(g(n)):",
                options: [
                    "Множество всех функций, порядок роста которых при достаточно больших n не больше некоторой константы c, умноженной на значение функции g(n)",
                    "Множество всех функций, порядок роста которых при достаточно больших n не меньше некоторой константы c, умноженной на значение функции g(n)",
                    "Множество всех функций, порядок роста которых при достаточно больших n точно равен значению функции g(n)",
                    "Множество всех функций, порядок роста которых при достаточно больших n отличается от g(n) не более чем в константу раз"
                ],
                correct: 0,
                explanation: "O-нотация определяет верхнюю границу роста функции, т.е. f(n) растет не быстрее, чем g(n) с точностью до постоянного множителя."
            },
            {
                number: 35,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма интерполяционного поиска в среднем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(log(log n))",
                    "f(n)=ϴ(n)"
                ],
                correct: 2,
                explanation: "В среднем случае интерполяционный поиск имеет сложность O(log(log n)), что делает его очень эффективным для больших равномерно распределенных данных."
            },
            {
                number: 36,
                text: "Укажите асимптотическую сложность операции удаления элемента, на который имеется указатель (например, ptr), из двунаправленного списка размером n:",
                options: [
                    "O(1)",
                    "O(log n)",
                    "O(n)",
                    "O(n²)"
                ],
                correct: 0,
                explanation: "В двунаправленном списке при наличии указателя на удаляемый элемент операция удаления выполняется за постоянное время O(1)."
            },
            {
                number: 37,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска по бинарному дереву поиска (binary search tree, BST) в лучшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 1,
                explanation: "В лучшем случае (сбалансированное дерево) поиск в бинарном дереве поиска имеет логарифмическую сложность O(log n)."
            },
            {
                number: 38,
                text: "Какое количество узлов в полном бинарном дереве высотой 4?",
                options: [
                    "15",
                    "16",
                    "31",
                    "32"
                ],
                correct: 2,
                explanation: "Количество узлов в полном бинарном дереве высотой h вычисляется по формуле 2^(h+1)-1. Для h=4: 2^5-1=32-1=31."
            },
            {
                number: 39,
                text: "Отличительная особенность алгоритма Бойера-Мура:",
                options: [
                    "Сравнение символов производится начиная с начала образца",
                    "Сравнение символов производится начиная с конца образца",
                    "Использует хеш-функцию",
                    "Основан на построении дерева"
                ],
                correct: 1,
                explanation: "Алгоритм Бойера-Мура сравнивает символы образца с текстом, начиная с конца образца, что позволяет делать большие сдвиги."
            },
            {
                number: 40,
                text: "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма: int count = 1; while (count < n) { count = count * 2; }",
                options: [
                    "Константная",
                    "Линейная",
                    "Логарифмическая",
                    "Квадратичная"
                ],
                correct: 2,
                explanation: "Цикл выполняется до тех пор, пока count < n, и count удваивается на каждой итерации. Количество итераций равно log₂n, поэтому сложность O(log n)."
            },
            {
                number: 41,
                text: "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=Ω(g(n)) и сравнением двух действительных чисел а и b:",
                options: [
                    "а ≤ b",
                    "а ≥ b",
                    "а = b",
                    "а ≠ b"
                ],
                correct: 1,
                explanation: "Ω-нотация означает, что f(n) растет не медленнее, чем g(n) (с точностью до постоянного множителя), аналогично a ≥ b."
            },
            {
                number: 42,
                text: "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов поиска:",
                options: [
                    "Только операции сравнения",
                    "Только операции перемещения данных",
                    "Операции сравнения и перемещения данных",
                    "Операции ввода-вывода"
                ],
                correct: 2,
                explanation: "При оценке сложности алгоритмов поиска учитывают как операции сравнения (для определения соответствия), так и операции перемещения данных (для доступа к элементам)."
            },
            {
                number: 43,
                text: "Пример какой структуры данных изображён на рисунке?",
                options: [
                    "Очередь",
                    "Стек",
                    "Дек",
                    "Дерево"
                ],
                correct: 2,
                explanation: "На рисунке изображен дек (double-ended queue) - структура данных, позволяющая добавлять и удалять элементы с обоих концов."
            },
            {
                number: 44,
                text: "Какой из видов линейных списков лучше использовать при реализации задачи по проверке баланса круглых скобок (соответствие открывающей и закрывающей скобок: (()()) -- баланс)?",
                options: [
                    "Очередь",
                    "Стек",
                    "Дек",
                    "Односвязный список"
                ],
                correct: 1,
                explanation: "Для проверки баланса скобок идеально подходит стек, так как последняя открытая скобка должна закрываться первой (LIFO)."
            },
            {
                number: 45,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма интерполяционного поиска в худшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(log(log n))",
                    "f(n)=ϴ(n)"
                ],
                correct: 3,
                explanation: "В худшем случае, когда данные распределены неравномерно, интерполяционный поиск может выродиться в линейный поиск с сложностью O(n)."
            },
            {
                number: 46,
                text: "Для структуры данных очередь справедливо:",
                options: [
                    "Удаление элемента возможно с одной из сторон списка",
                    "Удаление элемента возможно с обеих сторон списка",
                    "Добавление элемента возможно только в начало",
                    "Добавление элемента возможно только в конец"
                ],
                correct: 0,
                explanation: "В очереди элементы добавляются с одного конца (задняя часть) и удаляются с другого конца (передняя часть)."
            },
            {
                number: 47,
                text: "В каких случаях алгоритм Кнута-Морриса-Пратта дает подлинный выигрыш по сравнению с другими алгоритмами поиска в тексте по образцу?",
                options: [
                    "Когда образец короткий",
                    "Когда неудачному сравнению образца с текстом предшествовало некоторое число совпадений",
                    "Когда алфавит мал",
                    "Когда текст отсортирован"
                ],
                correct: 1,
                explanation: "Алгоритм КМП эффективен, когда есть длинные совпадающие префиксы, так как он использует информацию о предыдущих сравнениях для определения следующей позиции."
            },
            {
                number: 48,
                text: "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=О(g(n)) и сравнением двух действительных чисел а и b:",
                options: [
                    "а ≤ b",
                    "а ≥ b",
                    "а = b",
                    "а ≠ b"
                ],
                correct: 0,
                explanation: "O-нотация означает, что f(n) растет не быстрее, чем g(n) (с точностью до постоянного множителя), аналогично a ≤ b."
            },
            {
                number: 49,
                text: "Имеется бинарное дерево поиска, содержащее целые числа. Просмотр дерева даёт следующий результат: 2, 4, 6, 8, 10, 12, 14. Какой способ обхода дерева при этом использовался:",
                options: [
                    "Прямой (pre-order)",
                    "Обратный (post-order)",
                    "Симметричный (in-order)",
                    "По уровням (level-order)"
                ],
                correct: 2,
                explanation: "В бинарном дереве поиска симметричный обход (in-order) всегда дает отсортированную последовательность значений."
            },
            {
                number: 50,
                text: "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма: for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) cout<<'hello';",
                options: [
                    "Константная",
                    "Линейная",
                    "Квадратичная",
                    "Кубическая"
                ],
                correct: 2,
                explanation: "Алгоритм содержит два вложенных цикла, каждый из которых выполняется n раз, поэтому общее количество итераций равно n*n = n², что соответствует квадратичной сложности."
            },
            {
                number: 51,
                text: "Выберите все характеристики хеш-функции, используемой в алгоритме поиска Рабина-Карпа:",
                options: [
                    "Кольцевой (скользящий, летящий) хеш",
                    "Полиномиальный хеш",
                    "Модульная арифметика",
                    "Все перечисленные"
                ],
                correct: 3,
                explanation: "Алгоритм Рабина-Карпа использует кольцевой (скользящий) хеш на основе полиномиальной хеш-функции с применением модульной арифметики."
            },
            {
                number: 52,
                text: "Для структуры данных дек справедливо:",
                options: [
                    "Вставка нового элемента возможна в начало или в конец списка",
                    "Вставка нового элемента возможна только в начало списка",
                    "Вставка нового элемента возможна только в конец списка",
                    "Вставка нового элемента возможна в любую позицию списка"
                ],
                correct: 0,
                explanation: "Дек (double-ended queue) позволяет добавлять и удалять элементы как с начала, так и с конца списка."
            },
            {
                number: 53,
                text: "Какой формулой определяется максимальное количество узлов в бинарном дереве высотой k (у корня высота 0)?",
                options: [
                    "2^k",
                    "2^(k+1) - 1",
                    "2^(k+1)",
                    "k^2"
                ],
                correct: 1,
                explanation: "Максимальное количество узлов в бинарном дереве высотой k (при высоте корня 0) равно 2^(k+1)-1."
            },
            {
                number: 54,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма бинарного (двоичного) поиска в худшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 1,
                explanation: "Бинарный поиск в худшем случае требует log₂n сравнений, поэтому его сложность O(log n)."
            },
            {
                number: 55,
                text: "Перед выполнением какой операции в линейном двусвязном списке необходимо выполнить два 'подготовительных' оператора: q->prev->next=q->next; q->next->prev=q->prev;",
                options: [
                    "Добавление элемента",
                    "Удаление узла по указателю q",
                    "Поиск элемента",
                    "Обход списка"
                ],
                correct: 1,
                explanation: "Данные операторы перенаправляют ссылки соседних узлов, чтобы исключить узел q из списка, что является частью операции удаления."
            },
            {
                number: 56,
                text: "Когда достигается максимальная эффективность алгоритма Бойера-Мура?",
                options: [
                    "Если образец короткий, а мощность алфавита мала",
                    "Если образец длинный, а мощность алфавита достаточно велика",
                    "Если текст отсортирован",
                    "Если образец является палиндромом"
                ],
                correct: 1,
                explanation: "Алгоритм Бойера-Мура наиболее эффективен, когда образец длинный, а алфавит имеет большую мощность, так как это позволяет делать большие сдвиги."
            },
            {
                number: 57,
                text: "Укажите свойство, характеризующее структуру данных Дек:",
                options: [
                    "Вставка нового элемента возможна в заданную позицию",
                    "Вставка нового элемента возможна в начало или в конец",
                    "Удаление элемента возможно только с одного конца",
                    "Элементы хранятся в отсортированном порядке"
                ],
                correct: 1,
                explanation: "Основное свойство дека - возможность добавления и удаления элементов как с начала, так и с конца структуры."
            },
            {
                number: 58,
                text: "В каком типе деревьев лист не должен содержать значение?",
                options: [
                    "Бинарное дерево поиска",
                    "АВЛ-дерево",
                    "B-дерево",
                    "Красно-черное дерево"
                ],
                correct: 2,
                explanation: "В B-дереве все листья находятся на одном уровне и не содержат данных, служа только для завершения структуры."
            },
            {
                number: 59,
                text: "Что измеряется для оценки временной (вычислительной) сложности алгоритма:",
                options: [
                    "Размер исполняемого файла",
                    "Количество строк кода",
                    "Зависимость количества выполняемых основных операций от объёма входа",
                    "Объем используемой памяти"
                ],
                correct: 2,
                explanation: "Временная сложность алгоритма оценивает зависимость количества выполняемых основных операций от размера входных данных."
            },
            {
                number: 60,
                text: "Временная (вычислительная) сложность алгоритма определяется объёмом входа n. Этот параметр в частном случае может определяться:",
                options: [
                    "Размером обрабатываемого массива или файла",
                    "Количеством процессоров",
                    "Скоростью выполнения операций",
                    "Объемом оперативной памяти"
                ],
                correct: 0,
                explanation: "Объем входа n обычно определяется размером обрабатываемых данных - количеством элементов в массиве или размера файла."
            },
            {
                number: 61,
                text: "Линейные списки находят применение в технологии:",
                options: [
                    "Распределённых систем блокчейн",
                    "Базах данных",
                    "Графических процессорах",
                    "Всех перечисленных"
                ],
                correct: 3,
                explanation: "Линейные списки используются во многих областях, включая распределенные системы (блокчейн), базы данных и графические процессоры."
            },
            {
                number: 62,
                text: "В основе алгоритма Кнута-Морриса-Пратта используется:",
                options: [
                    "Эвристика стоп-символов",
                    "Префикс-функция",
                    "Хеш-функция",
                    "Дерево поиска"
                ],
                correct: 1,
                explanation: "Алгоритм Кнута-Морриса-Пратта использует префикс-функцию для определения максимального суффикса, который является префиксом."
            },
            {
                number: 63,
                text: "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=ϴ(g(n)):",
                options: [
                    "Множество всех функций, порядок роста которых при достаточно больших n не больше некоторой константы c, умноженной на значение функции g(n)",
                    "Множество всех функций, порядок роста которых при достаточно больших n не меньше некоторой константы c, умноженной на значение функции g(n)",
                    "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей",
                    "Множество всех функций, порядок роста которых точно равен g(n)"
                ],
                correct: 2,
                explanation: "Θ-нотация означает, что f(n) растет с той же скоростью, что и g(n) - существуют константы c₁ и c₂, такие что c₁*g(n) ≤ f(n) ≤ c₂*g(n) для достаточно больших n."
            },
            {
                number: 64,
                text: "Для каких узлов необходимо проверить коэффициент балансировки (баланс-фактор) после добавления узла в АВЛ-дерево?",
                options: [
                    "Только для нового узла",
                    "Только для непосредственного родителя нового узла",
                    "Для всех предков нового узла вплоть до корня дерева",
                    "Только для корня дерева"
                ],
                correct: 2,
                explanation: "После вставки нового узла в АВЛ-дерево необходимо проверить баланс всех его предков вплоть до корня, так как нарушение баланса могло произойти на любом уровне."
            },
            {
                number: 65,
                text: "Дисциплина обслуживания (порядок выполнения операций) стека:",
                options: [
                    "FIFO",
                    "LIFO",
                    "Приоритетная",
                    "Круговая"
                ],
                correct: 1,
                explanation: "Стек работает по принципу LIFO (Last In, First Out) - последний пришедший элемент обслуживается первым."
            },
            {
                number: 66,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в тексте по образцу методом Бойера-Мура в лучшем случае?",
                options: [
                    "f(n, m)=ϴ(n/m)",
                    "f(n, m)=ϴ(log(n/m))",
                    "f(n, m)=ϴ(n+m)",
                    "f(n, m)=ϴ(n*m)"
                ],
                correct: 0,
                explanation: "В лучшем случае алгоритм Бойера-Мура может пропускать большие участки текста, достигая сложности O(n/m), где n - длина текста, m - длина образца."
            },
            {
                number: 67,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма линейного (последовательного) поиска в худшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 2,
                explanation: "В худшем случае линейный поиск требует просмотра всех n элементов массива, поэтому его сложность O(n)."
            },
            {
                number: 68,
                text: "Что определяет термин 'чёрная высота' узла в структуре красно-черного дерева?",
                options: [
                    "Количество черных узлов на пути от корня до листового узла",
                    "Количество всех узлов на пути от корня до листового узла",
                    "Высоту поддерева с корнем в данном узле",
                    "Разницу высот левого и правого поддеревьев"
                ],
                correct: 0,
                explanation: "Черная высота узла в красно-черном дереве - это количество черных узлов на любом пути от этого узла до листа (не включая сам узел)."
            },
            {
                number: 69,
                text: "Какие из перечисленных АВЛ-деревьев не требуют проведения перестройки?",
                options: [
                    "1, 2, 4",
                    "1, 3, 4",
                    "2, 3, 4",
                    "1, 2, 3"
                ],
                correct: 0,
                explanation: "АВЛ-деревья 1, 2 и 4 имеют баланс-фактор в пределах [-1, 1], поэтому не требуют перестройки."
            },
            {
                number: 70,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в тексте по образцу методом Кнута-Морриса-Пратта в лучшем случае?",
                options: [
                    "f(n, m)=ϴ(n/m)",
                    "f(n, m)=ϴ(log(n/m))",
                    "f(n, m)=ϴ(n+m)",
                    "f(n, m)=ϴ(n*m)"
                ],
                correct: 2,
                explanation: "Алгоритм Кнута-Морриса-Пратта имеет сложность O(n+m) в худшем случае, которая сохраняется и в лучшем случае."
            },
            {
                number: 71,
                text: "Какую операцию можно использовать в качестве хеш-функции для целочисленных ключей?",
                options: [
                    "Операцию взятия остатка от деления ключа на размерность массива",
                    "Операцию умножения ключа на константу",
                    "Операцию сложения ключа с константой",
                    "Любую из перечисленных"
                ],
                correct: 3,
                explanation: "Для целочисленных ключей можно использовать различные операции, включая взятие остатка, умножение на константу или сложение, в зависимости от требований к распределению."
            },
            {
                number: 72,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма прямого поиска в тексте по образцу в худшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 3,
                explanation: "Прямой поиск (наивный алгоритм) в худшем случае имеет сложность O(n*m), где n - длина текста, m - длина образца. Если m сравнимо с n, то сложность O(n²)."
            },
            {
                number: 73,
                text: "Когда один алгоритм считается эффективнее другого:",
                options: [
                    "Если он использует меньше памяти",
                    "Если его вычислительная сложность в наихудшем случае имеет более низкий порядок роста",
                    "Если он проще реализовать",
                    "Если он работает быстрее на конкретном наборе данных"
                ],
                correct: 1,
                explanation: "Алгоритм считается более эффективным, если его асимптотическая сложность в наихудшем случае имеет более низкий порядок роста."
            },
            {
                number: 74,
                text: "При каком значении баланс-фактора b (т.е. разницы высот правого и левого поддеревьев) необходимо выполнить перестройку АВЛ-дерева?",
                options: [
                    "|b| = 0",
                    "|b| = 1",
                    "|b| = 2",
                    "|b| > 2"
                ],
                correct: 2,
                explanation: "В АВЛ-дереве перестройка требуется, когда модуль баланс-фактора становится равным 2, что нарушает условие сбалансированности."
            },
            {
                number: 75,
                text: "Имеется описание структуры узла линейного односвязного списка: struct Tnode { Tdata data; XXXX next; } Какое определение должно быть у экземпляра этой структуры на месте XXXX?",
                options: [
                    "Tnode",
                    "*Tnode",
                    "&Tnode",
                    "Tnode[]"
                ],
                correct: 1,
                explanation: "В языке C++ для указателя на структуру того же типа используется синтаксис *Tnode."
            },
            {
                number: 76,
                text: "Какое из перечисленных АВЛ-деревьев требует балансировки?",
                options: [
                    "1",
                    "2",
                    "3",
                    "4"
                ],
                correct: 2,
                explanation: "АВЛ-дерево 3 имеет баланс-фактор 2, что превышает допустимое значение [-1, 1], поэтому требует балансировки."
            },
            {
                number: 77,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска хешированием в лучшем случае?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 0,
                explanation: "В лучшем случае, при отсутствии коллизий, поиск в хеш-таблице выполняется за постоянное время O(1)."
            },
            {
                number: 78,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма вставки ключа в бинарное дерево поиска в наилучшем случае?",
                options: [
                    "f(n)=О(1)",
                    "f(n)=О(log n)",
                    "f(n)=О(n)",
                    "f(n)=О(n²)"
                ],
                correct: 1,
                explanation: "В наилучшем случае (сбалансированное дерево) вставка в бинарное дерево поиска имеет логарифмическую сложность O(log n)."
            },
            {
                number: 79,
                text: "Зачем нужен заглавный элемент в двусвязном кольцевом списке?",
                options: [
                    "Чтобы указать на первый элемент",
                    "Чтобы уменьшить использование памяти",
                    "Чтобы упростить удаление элементов",
                    "Чтобы ускорить поиск"
                ],
                correct: 0,
                explanation: "Заглавный элемент в двусвязном кольцевом списке служит точкой входа и указывает на первый элемент списка."
            },
            {
                number: 80,
                text: "Дисциплина обслуживания (порядок выполнения операций) очереди:",
                options: [
                    "LIFO",
                    "FIFO",
                    "Приоритетная",
                    "Случайная"
                ],
                correct: 1,
                explanation: "Очередь работает по принципу FIFO (First In, First Out) - первый пришедший элемент обслуживается первым."
            },
            {
                number: 81,
                text: "Сколько указателей используется в структуре узла стека?",
                options: [
                    "0",
                    "1",
                    "2",
                    "3"
                ],
                correct: 1,
                explanation: "В реализации стека на основе связного списка каждый узел содержит один указатель на следующий элемент."
            },
            {
                number: 82,
                text: "Структура данных, работа с элементами которой организована по принципу FIFO (первый пришел - первый ушел), - это:",
                options: [
                    "стек",
                    "очередь",
                    "дек",
                    "список"
                ],
                correct: 1,
                explanation: "Очередь - это структура данных, работающая по принципу FIFO (First In, First Out)."
            },
            {
                number: 83,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска ключа в бинарном дереве поиска в наихудшем случае?",
                options: [
                    "f(n)=О(1)",
                    "f(n)=О(log n)",
                    "f(n)=О(n)",
                    "f(n)=О(n²)"
                ],
                correct: 2,
                explanation: "В наихудшем случае (вырожденное дерево) бинарное дерево поиска превращается в связный список, и поиск имеет линейную сложность O(n)."
            },
            {
                number: 84,
                text: "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов сортировки:",
                options: [
                    "Только операции сравнения",
                    "Только операции перемещения данных",
                    "Операции сравнения и перемещения данных",
                    "Операции ввода-вывода"
                ],
                correct: 2,
                explanation: "При оценке сложности алгоритмов сортировки учитывают как операции сравнения элементов, так и операции их перемещения."
            },
            {
                number: 85,
                text: "Величина сдвига при поиске образца в тексте определяется наибольшим значением из трёх, вычисленных, соответственно, по трём правилам (эвристикам) в алгоритме:",
                options: [
                    "Кнута-Морриса-Пратта",
                    "Бойера-Мура",
                    "Рабина-Карпа",
                    "Интерполяционного поиска"
                ],
                correct: 1,
                explanation: "Алгоритм Бойера-Мура использует три эвристики для определения величины сдвига: эвристика стоп-символа, эвристика хорошего суффикса и эвристика совпавшего префикса."
            },
            {
                number: 86,
                text: "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в сбалансированном бинарном дереве поиска?",
                options: [
                    "f(n)=ϴ(1)",
                    "f(n)=ϴ(log n)",
                    "f(n)=ϴ(n)",
                    "f(n)=ϴ(n²)"
                ],
                correct: 1,
                explanation: "В сбалансированном бинарном дереве поиска (например, АВЛ-дереве или красно-черном дереве) поиск имеет логарифмическую сложность O(log n)."
            }
        ];

        // Инициализация страницы
        document.addEventListener('DOMContentLoaded', function() {
            const questionsContainer = document.getElementById('questions-container');
            
            // Создание вопросов
            questions.forEach((question, index) => {
                const questionElement = document.createElement('div');
                questionElement.className = 'question';
                questionElement.id = `question-${index}`;
                
                let optionsHTML = '';
                question.options.forEach((option, optionIndex) => {
                    optionsHTML += `
                        <div class="option">
                            <input type="radio" id="q${index}-opt${optionIndex}" name="q${index}" value="${optionIndex}">
                            <label for="q${index}-opt${optionIndex}">${option}</label>
                        </div>
                    `;
                });
                
                questionElement.innerHTML = `
                    <div class="question-number">Вопрос ${question.number}</div>
                    <div class="question-text">${question.text}</div>
                    <div class="options">${optionsHTML}</div>
                    <div class="result" id="result-${index}"></div>
                    <div class="explanation" id="explanation-${index}">${question.explanation}</div>
                `;
                
                questionsContainer.appendChild(questionElement);
                
                // Добавляем обработчики событий для радио-кнопок
                question.options.forEach((option, optionIndex) => {
                    const radioBtn = document.getElementById(`q${index}-opt${optionIndex}`);
                    radioBtn.addEventListener('change', function() {
                        checkAnswer(index, parseInt(this.value));
                        updateProgress();
                    });
                });
            });
            
            // Обработчик кнопки показа результатов
            document.getElementById('show-results-btn').addEventListener('click', showResults);
            
            // Обработчик кнопки сброса
            document.getElementById('reset-btn').addEventListener('click', resetAnswers);
        });
        
        // Функция проверки ответа на конкретный вопрос
        function checkAnswer(questionIndex, userAnswer) {
            const question = questions[questionIndex];
            const questionElement = document.getElementById(`question-${questionIndex}`);
            const resultElement = document.getElementById(`result-${questionIndex}`);
            const explanationElement = document.getElementById(`explanation-${questionIndex}`);
            
            if (userAnswer === question.correct) {
                resultElement.textContent = "Правильно!";
                resultElement.className = "result correct-result";
                questionElement.classList.add('correct');
                questionElement.classList.remove('incorrect');
            } else {
                resultElement.textContent = "Неправильно!";
                resultElement.className = "result incorrect-result";
                questionElement.classList.add('incorrect');
                questionElement.classList.remove('correct');
            }
            
            resultElement.style.display = 'block';
            explanationElement.style.display = 'block';
        }
        
        // Функция обновления прогресса
        function updateProgress() {
            let answeredCount = 0;
            
            questions.forEach((question, index) => {
                const selectedOption = document.querySelector(`input[name="q${index}"]:checked`);
                if (selectedOption) {
                    answeredCount++;
                }
            });
            
            const progress = Math.round((answeredCount / questions.length) * 100);
            document.getElementById('progress').style.width = `${progress}%`;
            document.getElementById('progress-value').textContent = progress;
        }
        
        // Функция показа общих результатов
        function showResults() {
            let correctCount = 0;
            let answeredCount = 0;
            
            questions.forEach((question, index) => {
                const selectedOption = document.querySelector(`input[name="q${index}"]:checked`);
                
                if (selectedOption) {
                    answeredCount++;
                    const userAnswer = parseInt(selectedOption.value);
                    
                    if (userAnswer === question.correct) {
                        correctCount++;
                    }
                }
            });
            
            // Обновление статистики
            document.getElementById('correct-count').textContent = correctCount;
            document.getElementById('incorrect-count').textContent = answeredCount - correctCount;
            
            const totalQuestions = questions.length;
            const score = Math.round((correctCount / totalQuestions) * 100);
            document.getElementById('score').textContent = `${score}%`;
            
            // Показ результатов
            document.getElementById('results').style.display = 'block';
        }
        
        // Функция сброса всех ответов
        function resetAnswers() {
            questions.forEach((question, index) => {
                const questionElement = document.getElementById(`question-${index}`);
                questionElement.classList.remove('correct', 'incorrect');
                
                const resultElement = document.getElementById(`result-${index}`);
                resultElement.style.display = 'none';
                
                const explanationElement = document.getElementById(`explanation-${index}`);
                explanationElement.style.display = 'none';
                
                const selectedOption = document.querySelector(`input[name="q${index}"]:checked`);
                if (selectedOption) {
                    selectedOption.checked = false;
                }
            });
            
            document.getElementById('results').style.display = 'none';
            updateProgress();
        }
    </script>
</body>
</html>